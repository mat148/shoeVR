<!doctype html>
<html lang="en">
<head>
    <title>Template (Three.js)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>
<body>

<script src="js/three.min.js"></script>
<script src="js/main.js"></script>
<script src="js/Detector.js"></script>
<script src="js/Stats.js"></script>
<script src="js/OrbitControls.js"></script>
<!--<script src="js/KeyboardState.js"></script>-->
  
<script src="js/BinaryLoader.js"></script>
<script src="js/WebGLDeferredRenderer.js"></script>
<script src="js/ShaderDeferred.js"></script>

<script src="js/CopyShader.js"></script>
<script src="js/FXAAShader.js"></script>

<script src="js/EffectComposer.js"></script>
<script src="js/RenderPass.js"></script>
<script src="js/ShaderPass.js"></script>
<script src="js/MaskPass.js"></script>
  
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>
<script src="js/DeviceOrientationControls.js"></script>
    
<script src="js/OBJLoader.js"></script>
<script src="js/OBJMTLLoader.js"></script>
<script src="js/MTLLoader.js"></script>

<!-- Code to display an information button and box when clicked. -->
<script src="js/jquery-1.11.2.min.js"></script>
<!--<script src="js/jquery-ui.js"></script>-->
<!--<link rel=stylesheet href="css/jquery-ui.css" />
<link rel=stylesheet href="css/info.css"/>-->

<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>

    
<script>
/*
	Three.js "tutorials by example"
	Author: Lee Stemkoski
	Date: July 2013 (three.js v59dev)
 */

// MAIN

// standard global variables
var container, scene, camera, renderer, controls, stats, loader;
//var keyboard = new KeyboardState();
var clock = new THREE.Clock();
  
var SHADOW_MAP_WIDTH = 2048, SHADOW_MAP_HEIGHT = 1024;

// custom global variables
var FloorDiskFire, FloorDiskWater, FloorDiskEarth, FloorDiskAir;
var firePillar, waterPillar, earthPillar, airPillar;

loadObjects();
init();
animate();

// FUNCTIONS 		
function init() 
{
	// SCENE
	scene = new THREE.Scene();
  
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
    camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
    controls = new THREE.DeviceOrientationControls( camera );
	scene.add(camera);
	camera.position.set(0,150,0);
  
	scene.fog = new THREE.FogExp2(0x6a3e6d, 0.00055);
  
	//camera.rotation.x = -90;
	// RENDERER
	if ( Detector.webgl ){
		renderer = new THREE.WebGLRenderer( {antialias:true} );
        //renderer = new THREE.WebGLDeferredRenderer( { antialias: true } );
        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        renderer.shadowMapEnabled = true;
        renderer.shadowMapType = THREE.PCFSoftShadowMap;
    }
	/*else{
      renderer = new THREE.CanvasRenderer(); 
      renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
      renderer.shadowMapEnabled = true;
      renderer.shadowMapType = THREE.PCFSoftShadowMap;
      renderer.shadowMapSoft = true;
    }*/
  
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
  
	// CONTROLS
	//controls = new THREE.OrbitControls( camera, renderer.domElement );
  
	// STATS
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.bottom = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );
    
    var infiniteFloorTexture = new THREE.MeshPhongMaterial({
        color: 0x062537,
        magFiler: THREE.LinearFilter,
        //ambient: 0xffffff,
        //specular: 0xffffff,
        //emissive: 0x083650,
        side: THREE.DoubleSide,
        //shininess: 50,
      });
    
    var infiniteFloor = new THREE.Mesh(new THREE.PlaneBufferGeometry(20000, 20000, 10, 10), infiniteFloorTexture);
    infiniteFloor.overdraw = true;
	infiniteFloor.position.y = -1;
	infiniteFloor.rotation.x = Math.PI / 2;
    infiniteFloor.castShadow = false;
    infiniteFloor.receiveShadow = true;
	scene.add(infiniteFloor);
    
	// skybox
	var geometry = new THREE.SphereGeometry(10000, 64, 32);

	var vertices = geometry.vertices;
	var faces = geometry.faces;

	//var purple = new THREE.Color(0x6a3e6d);
    var medpurple = new THREE.Color(0xbd4b8e);
	var pink = new THREE.Color(0xe05ca0);
	var tan = new THREE.Color(0xfccdc2);

	for (var i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];

      var vertex1 = vertices[face.a];
      var vertex2 = vertices[face.b];
      var vertex3 = vertices[face.c];

      var color1 = tan.clone();
      var color2 = tan.clone();
      var color3 = tan.clone();
//      color1.lerp(vertex1.y > 0 ? colorTop : colorBottom, Math.abs(vertex1.y) / 6000);
      
      if (vertex1.y > 10000) {
        // Purple
        color1.lerp(medpurple, Math.abs(vertex1.y) / 6000);
      } else if (vertex1.y >100) {
        // Pink
        color1.lerp(pink, Math.abs(vertex1.y) / 6000);
      } else if (vertex1.y > 000) {
        // Tan
        color1.lerp(tan, Math.abs(vertex1.y) / 6000);
      } else {
        // Purple
        color1.lerp(medpurple, Math.abs(vertex1.y) / 6000);
      }
      
      if (vertex2.y > 10000) {
        // Purple
        color2.lerp(medpurple, Math.abs(vertex2.y) / 6000);
      } else if (vertex2.y >100) {
        // Pink
        color2.lerp(pink, Math.abs(vertex2.y) / 6000);
      } else if (vertex2.y > 000) {
        // Tan
        color2.lerp(tan, Math.abs(vertex2.y) / 6000);
      } else {
        // Purple
        color2.lerp(medpurple, Math.abs(vertex2.y) / 6000);
      }
      
      if (vertex3.y > 10000) {
        // Purple
        color3.lerp(medpurple, Math.abs(vertex3.y) / 6000);
      } else if (vertex3.y >100) {
        // Pink
        color3.lerp(pink, Math.abs(vertex3.y) / 6000);
      } else if (vertex3.y > 000) {
        // Tan
        color3.lerp(tan, Math.abs(vertex3.y) / 6000);
      } else {
        // Purple
        color3.lerp(medpurple, Math.abs(vertex3.y) / 6000);
      }

      face.vertexColors.push(color1, color2, color3);

	}

	var material = new THREE.MeshBasicMaterial({
		vertexColors: THREE.VertexColors,
		side: THREE.BackSide,
		depthWrite: false,
		//depthTest: false,
		fog: false,
	});

	sky = new THREE.Mesh(geometry, material);
	scene.add(sky);
	
	////////////
	// CUSTOM //
	////////////
  
    var runnerTexture = new THREE.ImageUtils.loadTexture( 'img/testTile.png' );
	testAni = new TextureAnimator( runnerTexture, 4, 4, 16, 750 ); // texture, #horiz, #vert, #total, duration.
	var runnerMaterial = new THREE.MeshBasicMaterial( { map: runnerTexture, side:THREE.DoubleSide } );
  
    var runner2Texture = new THREE.ImageUtils.loadTexture( 'img/explosion.jpg' );
	testAni2 = new TextureAnimator( runner2Texture, 4, 4, 16, 75 ); // texture, #horiz, #vert, #total, duration.
	var runner2Material = new THREE.MeshBasicMaterial( { map: runner2Texture, side:THREE.DoubleSide } );
    
    // cylinder
    
    //var pillarMaterial = new THREE.MeshLambertMaterial( { color: 0xeaeaea } );
    
    
  
    //IMPORT OBJECTS
    
    function addObjects(){
        scene.add(FloorDiskFire);
        //scene.add(FloorDiskEarth);
        //scene.add(FloorDiskWater);
        //scene.add(FloorDiskAir);
        
        scene.add(firePillar);
        scene.add(earthPillar);
        scene.add(waterPillar);
        scene.add(airPillar);
    };
    
    // LIGHT
    
    var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
	directionalLight.position.set(500, 1000, 0);
    directionalLight.castShadow = true;
    directionalLight.shadowBias = -0.0018;
    //directionalLight.shadowCameraVisible = true;
    directionalLight.shadowMapWidth = 2042;
    directionalLight.shadowMapHeight = 2042;
    
    //directionalLight.intensity = 0;
    
	scene.add(directionalLight);
  
    /*var pointLight = new THREE.PointLight(0xff0d0d, 5, 5000);
    pointLight.position.set(0, 10, 0);
    scene.add(pointLight);*/

	/*var hemisphereLight = new THREE.HemisphereLight(0x6a3e6d, 0x007c9a , 0.1);
	hemisphereLight.position.set(-1, 2, 1.5);
	scene.add(hemisphereLight);*/
  
    /*var spotLight = new THREE.SpotLight(0xffffff, 4.5, 0);
    //spotLight.target.position.set(-7.88, 0, -261.10);
    spotLight.castShadow = true;
    spotLight.shadowCameraNear = 1200;
    spotLight.shadowCameraFar = 2500;
    spotLight.shadowCameraFov = 50;

    spotLight.shadowBias = 0.0001;
    spotLight.shadowDarkness = 0.5;

    spotLight.shadowMapWidth = SHADOW_MAP_WIDTH;
    spotLight.shadowMapHeight = SHADOW_MAP_HEIGHT;
    spotLight.position.set(0, 213.83, 0);
    scene.add(spotLight);*/
    
    // add spotlight for the shadows
        /*var spotLight = new THREE.SpotLight(0xffffff);
        spotLight.position.set(-40, 120, -10);
        spotLight.castShadow = true;
        scene.add(spotLight);*/
  
    //var ambientLight = new THREE.AmbientLight(0xffffff);
    //ambientLight.color.setRGB( 255 * 0.005, 255 * 0.005, 255 * 0.005);
    //scene.add(ambientLight);
    
    setTimeout(function(){addObjects();},1000);
}
    
function loadObjects()
{
    loader = new THREE.JSONLoader();
    
    var floorDiskmaterial = new THREE.MeshPhongMaterial({
        map: THREE.ImageUtils.loadTexture('img/floorSceneMap.jpg'),
        transparent: true,
        color: 0xeaeaea,
        ambient: 0xeaeaea,
        overdraw: 0.5,
        //specular: 0x6a3e6d,
        shading: THREE.FlatShading,
        //fog: false,
        //shininess: 50,
    });
    
    loader.load( "models/floorScene.js", function( geometry ) {
        FloorDiskFire = new THREE.Mesh( geometry, floorDiskmaterial);
        FloorDiskFire.position.set(0,0.2,0);
        FloorDiskFire.castShadow = true;
        FloorDiskFire.receiveShadow = true;
        FloorDiskFire.scale.set(1.5,1.5,1.5);
        //FloorDiskFire.rotation.y = -0.78;
    } );
    
    //----Floor Disk Loader -----//
    
    /*var floorDiskmaterial = new THREE.MeshLambertMaterial({
        map: THREE.ImageUtils.loadTexture('img/FloorDiskMapColor.png'),
        transparent: true,
    });

    loader.load( "models/FloorDisk.js", function( geometry ) {
        FloorDiskFire = new THREE.Mesh( geometry, floorDiskmaterial);
        FloorDiskFire.position.set(-215,0,0);
        FloorDiskFire.castShadow = true;
        FloorDiskFire.receiveShadow = true;
        FloorDiskFire.rotation.y = -0.78;
    } );
    
    loader.load( "models/FloorDisk.js", function( geometry ) {
        FloorDiskEarth = new THREE.Mesh( geometry, floorDiskmaterial);
        FloorDiskEarth.position.set(0,0,215);
        FloorDiskEarth.castShadow = true;
        FloorDiskEarth.receiveShadow = true;
        FloorDiskEarth.rotation.y = 0.8;
    } );
    
    loader.load( "models/FloorDisk.js", function( geometry ) {
        FloorDiskWater = new THREE.Mesh( geometry, floorDiskmaterial);
        FloorDiskWater.position.set(215,0,0);
        FloorDiskWater.castShadow = true;
        FloorDiskWater.receiveShadow = true;
        FloorDiskWater.rotation.y = 2.4;
    } );
    
    loader.load( "models/FloorDisk.js", function( geometry ) {
        FloorDiskAir = new THREE.Mesh( geometry, floorDiskmaterial);
        FloorDiskAir.position.set(0,0,-215);
        FloorDiskAir.castShadow = true;
        FloorDiskAir.receiveShadow = true;
        FloorDiskAir.rotation.y = -2.35;
    } );*/
    
    //-----Pillar Loader------//
    
    var pillarMaterial = new THREE.MeshPhongMaterial({
        //map: THREE.ImageUtils.loadTexture('img/pillarMap.png'),
        //transparent: true,
        color: 0xeaeaea,
        ambient: 0xeaeaea,
        overdraw: 0.5,
        //specular: 0x6a3e6d,
        shading: THREE.FlatShading,
        //fog: false,
        //shininess: 50,
    });
    
    loader.load( "models/pillar.js", function( pillar ) {
        firePillar = new THREE.Mesh(pillar, pillarMaterial);
        firePillar.position.set(135,0,135);
        firePillar.castShadow = true;
        firePillar.receiveShadow = true;
        firePillar.scale.set(1.7,1.7,1.7);
    } );
    
    loader.load( "models/pillar.js", function( pillar ) {
        earthPillar = new THREE.Mesh(pillar, pillarMaterial);
        earthPillar.position.set(135,0,-135);
        earthPillar.castShadow = true;
        earthPillar.receiveShadow = true;
        earthPillar.scale.set(1.7,1.7,1.7);
    } );
    
    loader.load( "models/pillar.js", function( pillar ) {
        airPillar = new THREE.Mesh(pillar, pillarMaterial);
        airPillar.position.set(-135,0,135);
        airPillar.castShadow = true;
        airPillar.receiveShadow = true;
        airPillar.scale.set(1.7,1.7,1.7);
    } );
    
    loader.load( "models/pillar.js", function( pillar ) {
        waterPillar = new THREE.Mesh(pillar, pillarMaterial);
        waterPillar.position.set(-135,0,-135);
        waterPillar.castShadow = true;
        waterPillar.receiveShadow = true;
        waterPillar.scale.set(1.7,1.7,1.7);
    } );
}

function animate() 
{
    requestAnimationFrame( animate );
	render();		
	update();
    controls.update();
 
}

function update()
{
    
  var delta = clock.getDelta(); 
  
  testAni.update(1000 * delta);
  testAni2.update(1000 * delta);
	/*if ( keyboard.pressed("z") ) 
	{	  
		// do something
	}*/
	
	//controls.update();
    //camera.lookAt(firePillar.position);
	stats.update();
}

function render() 
{
	renderer.render( scene, camera );
  
//    cubeCamera.updateCubeMap( renderer, scene );
 
}
  
function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) 
{	
	// note: texture passed by reference, will be updated by the update function.
		
	this.tilesHorizontal = tilesHoriz;
	this.tilesVertical = tilesVert;
	// how many images does this spritesheet contain?
	//  usually equals tilesHoriz * tilesVert, but not necessarily,
	//  if there at blank tiles at the bottom of the spritesheet. 
	this.numberOfTiles = numTiles;
	texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
	texture.repeat.set( 1 / this.tilesHorizontal, 1 / this.tilesVertical );

	// how long should each image be displayed?
	this.tileDisplayDuration = tileDispDuration;

	// how long has the current image been displayed?
	this.currentDisplayTime = 0;

	// which image is currently being displayed?
	this.currentTile = 0;
		
	this.update = function( milliSec )
	{
		this.currentDisplayTime += milliSec;
		while (this.currentDisplayTime > this.tileDisplayDuration)
		{
			this.currentDisplayTime -= this.tileDisplayDuration;
			this.currentTile++;
			if (this.currentTile == this.numberOfTiles)
				this.currentTile = 0;
			var currentColumn = this.currentTile % this.tilesHorizontal;
			texture.offset.x = currentColumn / this.tilesHorizontal;
			var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
			texture.offset.y = currentRow / this.tilesVertical;
		}
	};
}

</script>
    
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-60488291-1', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>
